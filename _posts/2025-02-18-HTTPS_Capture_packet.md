---
layout: post
title: "HTTPS密文抓包"
date:   2025-02-27
tags: [cdn]
comments: true
author: xingsong
toc: true
---

在我们日常工作中，经常需要抓包分析各种异常的网络常见。
http是网络常见中最常见的一种，随着https的普及，我们生产环境中，大部分都为https的网站。而https所有的交互数据都是经过加密的。

<!-- more -->

# 概述

1. https的核心原理并不复杂，通过非对称加密传递密钥，然后拿这个密钥通过对称加密传递密文数据。
2. tls1.2原理简单点，通过客户端随机数，服务端随机数，以及预主密钥生成主密钥，然后通过主密钥加密数据。所以tls1.2版本中，我们只要知道了主密钥，就能解密数据。
3. tls1.3复杂许多，在1.2的基础上需要更多密钥，其原理可以参考: https://www.cnblogs.com/wusanga/p/17386098.html
4. 其实，无论原理如何，我们作为使用方，解密明文数据其实很简单，主要分为两个过程：
  - 记录密钥日志，抓取数据包
  - 在wireshark中导入密钥日志，打开抓取的数据包即可。
5. 记录密钥这个是大部分软件配套的功能，库都是有记录密钥功能的

# 常见获取密钥方式

## Linux 客户端

1. curl 通过设置 SSLKEYLOGFILE 环境变量记录密钥日志的。比如：
  - 添加环境变量：`[ops ~]$ export SSLKEYLOGFILE=/tmp/ssl.log`
  - 访问：`[ops ~]$ curl https://www.baidu.com` 
2. 此时使用 tls1.2 版本请求：`[ops ~]$ curl --tlsv1.2 https://www.baidu.com`
3. 之后查看ssl.log文件，发现密钥日志文件出现一行密钥内容。
  - 第一列是标签，tls1.2中就是客户端随机数。
  - 第二列就是客户端随机数。一次会话中客户端的随机数是固定的。所以，一般会用第二列标识会话。第二列相同就是同一个会话。
  - 第三列就是密钥了。在tls1.2中就是主密钥。

~~~ shell
$ cat /tmp/ssl.log 
# SSL/TLS secrets log file, generated by NSS
CLIENT_RANDOM 1b152f16c50cae5bcae6845dc1190e2b66d2ce5dfdcbcc3c59371911290aab08 dbc10f1d8ba7ee7b0cc6abc80ce51c2707cd547fa59e04810b2eabd455c59953430b53a06318e3ea9f946cfd4bbf0355
~~~

4. 用tls1.3版本测试下: `[ops ~]$ curl --tlsv1.3 https://www.baidu.com`
5. 再次查看密钥文件,就会发现多了几行，这是tls1.3 版本的https在整个协议过程中，需要用到的密钥，比较多。当然，我们仅仅是使用的话，不用过分深究。

~~~ shell
CLIENT_RANDOM 1695f088e0d89b5fd878799216638024a2ec2beac41ce6b62eefcae03f64fd18 49301b8e74869d647449177a4fe38a70632f72290dbad620de5f8f056e88789cf99fee2ee328c7e4cd0e06491ff835d9
CLIENT_HANDSHAKE_TRAFFIC_SECRET 212a11025b3beb91bf6b155053df0fd810ccf87fe0aa9f77a96aabfba904e85d 9dba8701d6610613fc33d803117a31d74b9b586e7e122442d8703558a7af2d3599ad3e3f282def968d782e1ba0c80af1
SERVER_HANDSHAKE_TRAFFIC_SECRET 212a11025b3beb91bf6b155053df0fd810ccf87fe0aa9f77a96aabfba904e85d 909915c792f5d8f831540b878d39c8aba37ef1b7562f512a0bc58c99fe91951a1cb617ab7b62f9d712ae43b330cf2888
CLIENT_TRAFFIC_SECRET_0 212a11025b3beb91bf6b155053df0fd810ccf87fe0aa9f77a96aabfba904e85d 0d6ebd5ace7d3a98fee708b6ef8a49806e723cceccfb6460b28b905a3941f4c59ba254ba6536776ac5080304b8e75156
SERVER_TRAFFIC_SECRET_0 212a11025b3beb91bf6b155053df0fd810ccf87fe0aa9f77a96aabfba904e85d eac9be50abd2489cea9f6b9cb1ca382e0a75a23e6df4a2d5f04e2d350806507e43f1cb2d940c266d4e7edc260bf0e6ea
EXPORTER_SECRET 212a11025b3beb91bf6b155053df0fd810ccf87fe0aa9f77a96aabfba904e85d 389bf874068ab12d872a4da94703150fac9255c9d4c5dc1abda242df9197c840746d94e5af220fe215c6a909e582ff98
~~~

当然 curl 的密钥记录是基于各种 ssl 库实现的，常见的有 openssl 。 **这些库本身提供了记录密钥日志文件的功能**

## Linux 服务端

常见的库 & 可用的库

### 1.Nginx sslkey 模块

模块参与编译Nginx: [**nginx sslkey github**](https://github.com/tiandrey/nginx-sslkeylog)

- 在编译nginx的时候，把这个开源库编译进nginx。nginx就可以通过访问日志的记录形式，记录tls密钥
- tls1.3的时候数据不太全，抓1.2还是够的

### 2.wireshark 自带的库

github代码: [**wireshark-notes**](https://github.com/Lekensteyn/wireshark-notes)

操作文档: [**nginx 提取 openssl key**](https://security.stackexchange.com/questions/216065/extracting-openssl-pre-master-secret-from-nginx)

### 3.ecapture 旁观者app

官网: [**ecapture**](https://ecapture.cc/zh/)

功能: 无CA证书HTTPS/TLS数据抓包 ———— eBPF技术驱动，支持Linux/Android（x86_64/Aarch64）

这款抓包APP，通过ebpf在程序或库中注入，数据处理的ebpf代码。直接在用户态抓取数据包。ebpf对内核有要求，这个比较重要，得看是不是适合。

# uprobe/kprobe获取密钥

> 日常故障排查，常用方式有: 日志、监控、抓包。不过监控数据是大体的，而日志能不能记录到错误，得看有没有对相关组件记录，就算记录了相关组件，也不一定有记录对应错误信息。<br>
> 排查时最好的情况是能复现，可以通过调试、抓包等方式排错。如果只能在线上、生产环境复现，又不能随意乱动，排查起来就更不方便; 这种情况内核探针就有了用武之地;

[**uprobe kernel文档**](https://www.kernel.org/doc/html/latest/trace/uprobetracer.html)

uprobe 是 Linux 内核中的一个动态跟踪工具，它允许你在用户空间的应用程序中设置探针，以便在应用程序执行特定代码时触发事件。
程序在编译后其实都是汇编程序，一堆汇编指令，而 uprobe 可以在这对汇编指令中插入其他的指令。假设执行一个 bash 命令的 readline 函数入口前插入 uprobe，每当 bash 执行到 readline 函数前都会先执行 uprobe，继而执行 readline 函数。同理，也能在函数的返回处插入 uprobe。当程序，比如 bash，执行到 readline 处时，就可以获取到此时的函数参数。所以理论上只要找到处理 ssl 的函数，在函数入口插入 uprobe，再找到保存密钥的寄存器，将其输出打印出来，获取到密钥信息，就可以解析https密文了，下述一些过程可用于参考: 

## 1.处理ssl的函数

openssl 作为常用的 ssl 库，不出所料提供了记录密钥日志文件的功能；
尝试找了下，发现了两个相关的函数 `SSL_CTX_set_keylog_callback (回调函数)` 和 `ssl_log_secret (日志记录)`
- SSL_CTX_set_keylog_callback: <span style="color: red;">SSL_CTX</span> 级别的函数，因此它会影响到所有从此上下文中创建的SSL对象。允许自定义密钥处理逻辑，常用于复杂调试环境;
- ssl_log_secret: 直接调用的函数，用于记录单个密钥，适合简单的场景

获取密钥不需太复杂场景 `ssl_log_secret` 即可，代码如下：
~~~
int ssl_log_secret(SSL *ssl,
                   const char *label,
                   const uint8_t *secret,
                   size_t secret_len)
~~~

## 2.解读函数



## 3.解析参数